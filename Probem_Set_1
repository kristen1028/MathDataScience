# Importing necessary libraries and modules
# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SFlf_ZjDVtHJbsu1z0Y40E8y4MzvkXZT
"""
```python
# Importing required libraries
import numpy as np
import matplotlib.pyplot as plt
import torch
from torchvision import datasets
from skimage.util import montage
!pip install wandb
import wandb as wb
from skimage.io import imread
```
# Define functions for GPU operations and plotting
def GPU(data):
    return torch.tensor(data, requires_grad=True, dtype=torch.float, device=torch.device('cuda'))

def GPU_data(data):
    return torch.tensor(data, requires_grad=False, dtype=torch.float, device=torch.device('cuda'))

def plot(x):
    """
    Plots an image represented by tensor 'x'.
    Args:
        x: Tensor representing an image.
    """
    if type(x) == torch.Tensor:
        x = x.cpu().detach().numpy()

    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap='gray')
    ax.axis('off')
    fig.set_size_inches(7, 7)
    plt.show()

def montage_plot(x):
    """
    Plots a montage of images represented by the tensor 'x'.
    Args:
        x: Tensor representing a collection of images.
    """
    x = np.pad(x, pad_width=((0, 0), (1, 1), (1, 1)), mode='constant', constant_values=0)
    plot(montage(x))

# Load MNIST dataset
train_set = datasets.MNIST('./data', train=True, download=True)
test_set = datasets.MNIST('./data', train=False, download=True)

# Preprocess image data
X = train_set.data.numpy()
X_test = test_set.data.numpy()
Y = train_set.targets.numpy()
Y_test = test_set.targets.numpy()

X = X[:, None, :, :] / 255
X_test = X_test[:, None, :, :] / 255

# Display the shape of X
X.shape

# Display the shape of a subset of X
X[0:25, 0, :, :].shape

# Plot a montage of images
montage_plot(X[125:150, 0, :, :])

# Reshape image tensors
X = X.reshape(X.shape[0], 784)
X_test = X_test.reshape(X_test.shape[0], 784)

# Convert data to GPU tensors
X = GPU_data(X)
Y = GPU_data(Y)
X_test = GPU_data(X_test)
Y_test = GPU_data(Y_test)

# Display the shape of X
X.shape

# Extract a subset of X
x = X[:, 0:64]

# Transpose X
X = X.T

# Display the shape of X
X.shape

# Create a random model 'M' and perform matrix multiplication
M = GPU(np.random.rand(10, 784))

# Set batch size
batch_size = 64

# Extract a batch of image data
x = X[:, 0:batch_size]

# Update the random model and perform matrix multiplication
M = GPU(np.random.rand(10, 784))
y = M @ x

# Calculate accuracy based on model predictions
y = torch.argmax(y, 0)
torch.sum((y == Y[0:batch_size])) / batch_size

# Train a random walk model to achieve at least 75% accuracy
m_best = 0
acc_best = 0

for i in range(100000):
    step = 0.0000000001
    m_random = GPU_data(np.random.randn(10, 784))
    m = m_best + step * m_random

    y = m @ X

    y = torch.argmax(y, axis=0)

    acc = ((y == Y)).sum() / len(Y)

    if acc > acc_best:
        print(acc.item())
        m_best = m
        acc_best = acc
```
